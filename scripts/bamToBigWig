#!/usr/bin/env python
"""Create a bigwig file with signal derived from a sorted and indexed bam file."""
###############################################################################
## bamToBigWig
## Create a bigwig file with signal derived from a sorted and indexed bam file.
## Copyright (C) 2016  Panos Firmpas
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## any later version.
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## You should have received a copy of the GNU General Public License
###############################################################################

from __future__ import print_function

from itertools import islice
from multiprocessing import Lock, Pool
import argparse
import os
import sys

import numpy as np
import pysam

if os.name == 'posix' and sys.version_info[0] < 3:
    try:
        import subprocess32 as subp
    except ImportError:
        import subprocess as subp
else:
    import subprocess as subp


def which(program):
    """Find out if "program" is available in the path.

    http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python
    """
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file
    return None


class FlagFilter():
    """This class instantiates a filter based on the args. The idea
    is to only ever expose one filtering fuction for the reads and
    not to have unnecessary elifs and clutter.
    It is a bit hacky but fun.
    I guess this could very well be just a function... TODO !
    """

    def __init__(self, args):
        if args.filter_lc and args.filter_uc:
            self.filter_func = self.both(args)
        elif args.filter_lc:
            self.filter_func = self.lc(args)
        elif args.filter_uc:
            self.filter_func = self.uc(args)
        else:
            self.filter_func = lambda x: True

    def both(self, args):
        flc = args.filter_lc
        fuc = args.filter_uc
        return lambda x: ((x & flc) == flc) and ((x & fuc) == 0)

    def lc(self, args):
        flc = args.filter_lc
        return lambda x: (x & flc) == flc
    def uc(self, args):
        fuc = args.filter_uc
        return lambda x: ((x & fuc) == 0)

class FragFilter():
    """This class instantiates a filter based on the args. The idea
    is to only ever expose one filtering fuction for the reads and
    not to have unnecessary elifs and clutter."""
    def __init__(self, args):
        if args.t_len_lower and args.t_len_upper:
            self.filter_func = self.both(args)
        elif args.t_len_lower:
            self.filter_func = self.lc(args)
        elif args.t_len_upper:
            self.filter_func = self.uc(args)
        else:
            self.filter_func = lambda x: True

    def both(self, args):
        tll = args.t_len_lower
        tlu = args.t_len_upper
        return lambda x: (x >= tll) and (x <= tlu)

    def lc(self, args):
        tll = args.t_len_lower
        return lambda x: (x >= tll)

    def uc(self, args):
        tlu = args.t_len_upper
        return lambda x: (x <= tlu)


def yield_chunks(args, chrom):
    bam = pysam.AlignmentFile(args.bam)
    # ff is a function that gets instantiated based on
    # the arguments. It returns True for acceptable reads
    f = FlagFilter(args)
    # the flag filter
    ff = f.filter_func

    fr = FragFilter(args)
    # the fragment length filter
    ffr = fr.filter_func

    # the quality filter
    if args.q:
        fq = lambda x: x >= args.q
    else:
        fq = lambda x: True

    # p strand constant
    ps_const = args.shift + args.shift_p
    # n strand constant
    # The +1 puts the CUT in the appropriate position, since otherwise the
    # position refers to the last mapped nucleotide of a - strand read.
    # the cut then is to the right of that nucleotide
    ns_const = - args.shift - args.shift_n - args.extsize + 1

    # This 'worker' will go through all the reads,
    # and with thoe reads that pass the various filters
    # it will create a dictionary
    # where d = { position: NumberofCuts }
    d = {}
    for read in bam.fetch(chrom, 0, args.chrom_size[chrom]):
        if ff(read.flag) and ffr(abs(read.template_length)) and fq(read.mapping_quality):
            if read.is_reverse:
                dpos = read.reference_end + ns_const
                d[dpos] = d.get(dpos, 0) + 1
            else:
                dpos = read.reference_start + ps_const
                d[dpos] = d.get(dpos, 0) + 1

    # Now that we have the dictionary
    # we can cast it in an iterable of tuples
    # Which we sort. This guarantees that
    # we are actually walking through the chromosome from its start
    # to its end, and we get the positions with cuts in proper order

    pairs = iter(sorted(d.items()))

    del d

    chunk = [pairs.next()]
    cpos = chunk[0][0]

    # A chunk is a collection (tuple) of position:numberofcuts pairs.
    # Since we only add signal to a certain range AFTER a 'cut'
    # [Note that the actual cutting sites have been moveed in the previous step,
    # the cuts in "pairs" are the positions from which we will add X bases of signal downstream]
    # we seggregate the positions in chunks where there is no greater distance between
    # each chunk than 'max_dist'

    # This allows the on-the-fly creation of a healthy wiggle file
    # since we don't want our wiggle to be full of zeroes
    max_dist = args.extsize + (args.bucket_size - 1)

    # so this bit of code here goes through all the pairs
    # and yields them in 'chunks'
    # Each chunk will be one "wiggle field"
    for pair in pairs:
        if pair[0] >= cpos + max_dist:
            yield chunk
            chunk = [pair]
            cpos = pair[0]
        else:
            chunk.append(pair)
            cpos = pair[0]
    # yield the last chunk
    yield chunk


def split_every(n, iterable):
    """splits an iterable every n values"""
    i = iter(iterable)
    piece = list(islice(i, n))
    while piece:
        yield piece
        piece = list(islice(i, n))


def yield_windows(args, chrom):
    '''In here we go from cut positions (not EXACTLY cuts but anyway)
    to windows of signal, each window will become one wiggle field'''
    chromsize = args.chrom_size.get(chrom)

    for chunk in yield_chunks(args, chrom):
        # window length
        wl = (chunk[-1][0] - chunk[0][0]) + args.extsize
        # window start
        ws = chunk[0][0]
        # the window itsself, a np array
        w = np.zeros(wl)

        wse = - ws + args.extsize
        for c, v in chunk:
            w[c - ws: c + wse] += v

        # this shouldnt happen, right? (It can happen if a read is near 0, thanks to shifts)
        if ws < 0:
            w = w[abs(ws):]
            ws = 0
        # hm, should I emulate bedtools and just sys.exit for no apparent reason ?
        if ws >= chromsize:
            continue
        # chop the window a bit if it exceeds chromosome size
        extra = (ws + len(w)) - chromsize
        if extra > 0:
            w = w[:-extra]
        # ufff
        if w.size == 0:
            continue

        # We have been 0-based so far
        # but wiggle is 1-based soooooo:
        yield ws + 1, w


def yield_window_str(args, chrom):
    '''String-format our windows'''

    st = args.bucket_size
    # we fill in the chrom and step
    cline = "fixedStep  chrom={}  start={{}} step={} span={}\n{{}}\n".format(chrom, st, st)
    # cline woman (cline), she drink coffee (cline), she drink tea (cline) [...]

    # squeeze a tiny bit more speed (ballsToTheWall)
    clinef = cline.format

    for ws, w in yield_windows(args, chrom):
        # reform the window if buckets
        if st > 1:
            w = np.array([np.mean(x) for x in split_every(st, w)])

        # transform the values to a string with one value per line
        vl = '\n'.join(w.astype(str))
        # make a string with the cline and the values
        wiggle_field = clinef(ws, vl)

        yield wiggle_field



def one_worker((args, chrom)):
    '''Each core will do this'''

    # This starts the cascade of iterators (yield_window_str --> yield_windows --> yield_chunks)
    # And ends with a big string
    toprint = "".join(yield_window_str(args, chrom))

    # Then we get the lock, write our bit string to the output and flush (flush is very important)
    with lock:
        wtbwpipe.write(toprint)
        wtbwpipe.flush()

    return '{} done!'.format(chrom)


def poolinit(l, p):
    """
    Initializes the pool and makes l and p globals among all the processes.

    http://stackoverflow.com/questions/25557686/python-sharing-a-lock-between-processes
    """
    global lock
    global wtbwpipe
    lock = l
    wtbwpipe = p


# def singledude(args):
#     fo = open( args.out, "w")

#     # get the chromosomes sorted by size, from the chrominfo file
#     loc = []
#     with open(args.chrominfo, "r") as fi:
#         for line in fi:
#             c, v = line.rstrip().split("\t")[:2]
#             loc.append((c, int(v)))
#     chroms = [x[0] for x in sorted(loc, reverse=True, key=lambda x: x[1])]
#     args.chrom_size = dict(loc)

#     for chrom in chroms:
#         toprint = "".join(yield_window_str(args, chrom))
#         fo.write(toprint)
#     fo.close()


def bamtobw(args):

    # get the chromosomes sorted by size, from the chrominfo file
    loc = []
    with open(args.chrominfo, "r") as fi:
        for line in fi:
            c, v = line.rstrip().split("\t")[:2]
            loc.append((c, int(v)))
    chroms = [x[0] for x in sorted(loc, reverse=True, key=lambda x: x[1])]
    args.chrom_size = dict(loc)

    # where will I write to
    if not args.towig:
        wtbw = subp.Popen(
            ["wigToBigWig", "-clip", "stdin", args.chrominfo, args.out],
            stdin=subp.PIPE,
            stdout=subp.PIPE)
        iwriteto = wtbw.stdin
    else:
        iwriteto = open(args.out, "w")

    iterabull = [(args, x) for x in chroms]
    l = Lock()
    pool = Pool(args.procs - 1, initializer=poolinit, initargs=(l, iwriteto, ))

    for message in pool.imap_unordered(one_worker, iterabull):
        pass

    pool.close()
    pool.join()

    if not args.towig:
        wtbw.stdin.close()
        wtbw.wait()
    else:
        iwriteto.close()


if __name__ == '__main__':
    # Define the Argparse 'things'

    parser = argparse.ArgumentParser(description="""
        Create a bigwig file with signal derived from a sorted and indexed bam file.  \
        Use the options to shape the signal according to what you are visualizing.    \
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
        Reads can be filtered with -f and/or -F which work like in "samtools view".   \
        Try the option --explain_flags for more help with this.                       \
        Reads can also be filtered by a lower/upper limit for tlen. See --t_len_upper \
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
        The reads can be shifted by --shift towards 5'->3' before being expanded by   \
        --extsize to expand their coverage. Try --coverage_examples for more help. You\
        can set strand specific shifting with --shift_p and --shift_n or use --atac   \
        to automatically correct the reads from ATACseq experiments.                  \
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
        Use -p to parallelize (at the very least 2 cores are recommended).            \
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
        Please report any issues at https://github.com/PanosFirmpas/bamToBigWig       \
        """, add_help=False)
    req = parser.add_argument_group('required arguments')

    req.add_argument('-b', '--bam', type=str, metavar='', help='The input .bam file. Must be sorted and indexed.')

    req.add_argument('-chr', '--chrominfo', type=str, metavar='', help='''
                       A two column |<chromosome name> <total_length>| txt file.
                       Required by wigToBigWig. The chromosome names must match those on the bam file. bamToBigWig only 
                       works on the chromosomes found in this file, so if you want to create a bigwig with only 
                       some chromosomes included, edit this input file accordingly.''')

    opt = parser.add_argument_group('optional arguments')

    opt.add_argument('-o', '--out', type=str, metavar='', help="""
                        The output .bw file. If not given, it will be /path/to/input(.bam).bw""")

    opt.add_argument('-q', '--q', type=int, default = None,metavar='', help="""
                        Only include reads with mapping quality >= this option. Default is None, no q filter is applied.""")

    opt.add_argument('-f', '--filter_lc', type=int, default = None,metavar='', help="""
                       Only include reads with all bits of this argument set in their flag. Default is None,
                       no read filter is applied. See --explain_flags""")

    opt.add_argument('-F','--filter_uc', type=int, default = 4, metavar='', help="""
                       Only include reads with none of the bits of this argument set in their flag. Default is 4, which 
                       filters out unmapped reads. If you don't want ANY such filter, you can set this option to 0 but this 
                       will likely cause the program to crash and burn since unmapped reads don't have some needed parameters like 
                       an alignment position. See --explain_flags for some more information.""")

    opt.add_argument('-tlu','--t_len_upper', type=int, default = None,metavar='', help="""
                       Sets filtering so that only reads with absolute(tlen) lower than this are accepted.
                       This field is set by the mapper, but for paired-end sequencing it will typically refer to the
                       distance from the start of the + strand mapped read to the end of its - strand mapped mate. 
                       For ATAC experiments, setting this to approximately 120, will visualize
                       the "nucleosome free" reads. Default is "None", no fragment size filter is applied.""")
    opt.add_argument('-tll', '--t_len_lower', type=int, default = None,metavar='', help="""
                       Sets filtering so that only reads with absolute(tlen) greater than this are accepted.
                       See also --t_len_upper""")

    opt.add_argument('-p', '--procs', type=int, default=4, help="""
                       The number of processors to use. Defaults to 4. One of those 
                       processors with be consumed by the wigToBigWig process. After that, each available 
                       processor works on one chromosome at a time until all chromosomes are done.""")

    opt.add_argument('-sh', '--shift', type=int, default=-3, metavar='', help="""
                        Arbitrary shift in bp. This value is used to move cutting ends (5') towards 5'->3'.
                        When this value is negative, ends will be moved toward 3'->5' direction.
                        If you want to extend the signal downstream of the original cutting end,
                        for example to visualize CHIPseq experiments, you will want to set this value to 0
                        and --extsize to how much you want to extend. If on the other hand you want to
                        extend the signal to both sides of the cutting end, for example if you are visualizing
                        ATACseq or DNAse-seq, you will want to set this to some negative value.
                        The default value -3 in combination with the default value of --extsize 7
                        will extend the signal by 3bp around the cutting end.
                        NOTE: this is different than the --atac option, or the --shift_p/shift_n options, and is applied on top of them.""")

    opt.add_argument('-exts', '--extsize', type=int, default=7, metavar='', help="""
                        Arbitrary extension size in bp. 
                        This value is used to extend each read towards 3' end.  
                        Can be usefully combined with --shift. The default value is 7 
                        which in combination with the default --shift -3 extends the signal 
                        by 3bp upstream and downstream of the original cutting end.""")

    opt.add_argument('-sh_p', '--shift_p', type=int, default=0, metavar='', 
                        help="Like --shift (and applied on top of it), but only applied to reads that map on the positive strand.")

    opt.add_argument('-sh_n', '--shift_n', type=int, default=0, metavar='', 
                        help="Like --shift (and applied on top of it), but only applied to reads that map on the negative strand.")

    opt.add_argument('-atac', '--atac', action='store_true', default=False, help="""
                        Shift reads mapping to the plus strand by +4 (5'->3') and reads that map
                        on the minus strand by 5 (5'-> 3'). This centers the cutting ends on the center of the
                        transposase 'event'. Overwrites --shift_p to 4 and --shift_n to 5""")
    opt.add_argument('-buck', '--bucket_size', type=int, default=1, metavar='', help=argparse.SUPPRESS)
    # """This will bucket the signal in -buck sized buckets. This will decrease resolution\
    # but will run faster and create a smaller sized bw file. \n\
    # Be advised, this will most probably leave bases with incorrect signal value in the .bw file. Default is 1""")

    opt.add_argument('-towig', '--towig', action='store_true', default=False,
                        help=argparse.SUPPRESS)

    opt.add_argument('-h', '--help', action='store_true', default=False,
                        help=argparse.SUPPRESS)

    ht = parser.add_argument_group('Extra Help', "")

    ht.add_argument('-exfl', '--explain_flags', action='store_true', help="Show some extra help about filtering reads with their flags.")
    # ht.add_argument('-exfi','--filter_examples', action='store_true',
    #                     help="Show some examples of filtering reads with their flags and exit.")
    ht.add_argument('-exco', '--coverage_examples', action='store_true', help="Show some examples of filtering reads with their flags and exit.")



    # No arguments given
    if len(sys.argv[1:]) == 0:
        parser.print_help()
        parser.exit()

    # parse the arguments
    args = parser.parse_args()

    if args.help:
        parser.print_help()
        parser.exit()

    # check if wigToBigWig is in the path
    if not which('wigToBigWig'):
        print('''This script relies on the ucsc utility wigToBigWig, \n\
which could not be found in your system. You can get it here:\n\
http://hgdownload.soe.ucsc.edu/admin/exe/ ''')
        sys.exit()

    # Ok, we parsed our arguments, let's deal with them:

    if args.explain_flags:
        print (
            """
    Theory:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Sequencing reads in sam/bam files contain a binary flag, which is a \n\
    combination of 12 bit-wise flags. They are set by the aligner/mapper. \n\
    This allows fast and efficient filtering of the reads.\n\n\
    If a read, for example, has its flag set to 2, we can see the bitwise flags\n\
    by converting 2 to its binary representation which is 000000000010 . The  \n\
    second bit/flag is set to 1, so it is True. This means that this imaginary\n\
    read belongs to a 'proper pair', meaning that both it and its mate were   \n\
    properly aligned by the aligner.\n\n\
    If you set the -f option to 2, you are making sure that only reads which  \n\
    have their second bitwise flag set to 1 will be used. By setting the -F   \n\
    option to 2, you are making sure that such reads are excluded.


    Some Examples:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    # Only use 'proper pair' reads (usually implies more filters)\n\
    >> bamToBigWig -b in.bam -chr chrm.txt -f 2 \n\n\
    # EXCLUDE 'proper pair' reads \n\
    >> bamToBigWig -b in.bam -chr chrm.txt -F 2 \n\n\
    # Only use reads that mapped on the '-' strand:\n\
    >> bamToBigWig -b in.bam -chr chrm.txt -f 16 \n\n\
    # Only use 'proper pair' reads that mapped on the '-' strand:\n\
    >> bamToBigWig -b in.bam -chr chrm.txt -f 18 \n\n\
    # Only use reads that mapped on the '+' strand (we exclude the '-' reads):\n\
    >> bamToBigWig -b in.bam -chr chrm.txt -F 16 \n\n\
    # Only use 'proper pair' reads that mapped on the '+' strand:\n\
    >> bamToBigWig -b in.bam -chr chrm.txt -f 2 -F 16 \n\n\

    More:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    An amazing resource to help you set your filters can be found here:  \n\
    https://broadinstitute.github.io/picard/explain-flags.html                \n\
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    """)
        parser.exit()

    if args.coverage_examples:
        print (
            """
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    # To visualize an ATACseq experiment, we use -atac to shift the reads \n\
    # appropriatelly, the --shift the reads upstream by 10 and expand the \n\
    # signal downstream of the cutting-site by 21. This expands the signal by \n\
    # 10bp each side of the cutting site.
    >> bamToBigWig -b in.bam -chr chrm.txt --shift -10 --extsize 21 \n\n\
    # To visualize a CHIPseq experiment, we expand the signal dowbstream of \n\
    # the cutting site by the experiment's fragment size, in this example: 300\n\
    >> bamToBigWig -b in.bam -chr chrm.txt --extsize 300 \n\n\
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    """)
        parser.exit()

    assert args.bam is not None, "You need to specify an input bam file !"
    assert args.chrominfo is not None, "You need to specify an chrom_info file !"
    assert os.path.exists(args.bam), "Designated input file {} doesn't doesn't seem to exist".format(args.bam)
    assert os.path.isfile(args.chrominfo), "Could not find {}".format(args.chrominfo)
    assert args.extsize >= 1

    # handle output path
    if args.out:
        pathto, out = os.path.split(args.out)
        if pathto == "":
            pathto = "."
        assert os.path.exists(pathto), "Designated output path {} doesn't exist".format(pathto)

        if not args.towig:
            if not out.endswith(".bw"):
                out = out + ".bw"
            args.out = os.path.join(pathto, out)
        else:
            if not out.endswith(".wig"):
                out = out + ".wig"
            args.out = os.path.join(pathto, out)
    else:
        pathto, out = os.path.split(args.bam)
        if not args.towig:
            out = out[:-3] + "bw"
        else:
            out = out[:-3] + "wig"
        args.out = os.path.join(pathto, out)

    if args.atac:
        if (args.shift_p != 0) or (args.shift_n != 0):
            print('''\n\n   You seem to have set both a specific value for --shift_p or --shift_n
   AND the -atac flag. The atac flag overrides the other two values so please
   use either shift_n/shift_p OR -atac/ \n\n''')
            sys.exit()

        args.shift_p = 4
        args.shift_n = 5

    # this used to default to None so the code was built around that
    # Now that it sensibly defaults to 4, the user would set it to 0
    # to get the same behaviour as None
    # so instead of changing the code ill just change this here
    if args.filter_uc == 0:
        args.filter_uc = None

    bamtobw(args)


## A little bit of helping code that creates a fake samfile for testing
## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##
# import pandas as pd
# import numpy as np
# from itertools import cycle
# chromNames = ['chr1','chr2']
# chromLengths = [10000,10000]
# headline = lambda chromName,chromLength : "@SQ\tSN:{}\tLN:{}".format(chromName, chromLength)
# header = "\n".join([headline(x,y) for x,y in zip(chromNames,chromLengths)])
# df = pd.DataFrame(columns = ["QNAME","FLAG","RNAME","POS","MAPQ","CIGAR","RNEXT","PNEXT","TLEN","SEQ","QUAL"])
# df["FLAG"] = np.arange(216)
# df['POS'] = 100
# mapqs = cycle(np.arange(0,28))
# df['MAPQ'] = [next(mapqs) for _ in np.arange(216)]
# tlens = cycle(np.arange(20,1000,50))
# df["TLEN"] = [next(tlens) for _ in np.arange(216)]
# df['QNAME'] = df['FLAG'].apply(lambda x: "{}_yolo".format(x))
# df['RNAME'] = "chr1"
# df["CIGAR"] = "49M"
# df["RNEXT"] = "chr1"
# df["PNEXT"] = df['POS'] + 50
# df['SEQ'] = 'A'*49
# df['QUAL'] = '!'*49
# with open("fake.sam", 'w') as fo:
#     fo.write(header)
#     fo.write("\n")
#     df.to_csv(fo, sep="\t", index=False, header=False)
# #samtools view -b fake.sam > fake.bam && samtools sort fake.bam -o fake.s.bam && samtools index fake.s.bam

## This prints binary flags kinda nicely, putting it here cause otherwise ill lose it and i dont want to google it again
# for i in range(100):
#     print "{}\t{:0>16b}\t{:0>16b}\t{}".format(i,i,17, (i&17) )
